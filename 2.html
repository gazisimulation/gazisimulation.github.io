<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Atom Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #controls h3 {
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        select, input {
            width: 100%;
            margin-top: 3px;
            margin-bottom: 10px;
        }
        button {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        .slider-value {
            display: inline-block;
            width: 40px;
            text-align: right;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3>Quantum Atom Simulator</h3>
        
        <div class="control-group">
            <label for="element">Element:</label>
            <select id="element">
                <option value="1">Hydrogen (H)</option>
                <option value="2">Helium (He)</option>
                <option value="3">Lithium (Li)</option>
                <option value="4">Beryllium (Be)</option>
                <option value="5">Boron (B)</option>
                <option value="6">Carbon (C)</option>
                <option value="7">Nitrogen (N)</option>
                <option value="8">Oxygen (O)</option>
                <option value="9">Fluorine (F)</option>
                <option value="10">Neon (Ne)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="orbital">Orbital Visualization:</label>
            <select id="orbital">
                <option value="all">All Orbitals</option>
                <option value="1s">1s</option>
                <option value="2s">2s</option>
                <option value="2p">2p</option>
                <option value="3s">3s</option>
                <option value="3p">3p</option>
                <option value="3d">3d</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="visualization">Visualization Type:</label>
            <select id="visualization">
                <option value="cloud">Electron Cloud</option>
                <option value="boundary">Boundary Surface</option>
                <option value="dots">Probability Dots</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="probability">Electron Probability Threshold: <span id="probability-value" class="slider-value">0.75</span></label>
            <input type="range" id="probability" min="0.01" max="0.99" step="0.01" value="0.75">
        </div>
        
        <div class="control-group">
            <label for="quality">Rendering Quality: <span id="quality-value" class="slider-value">50</span></label>
            <input type="range" id="quality" min="10" max="100" step="5" value="50">
        </div>
        
        <div class="control-group">
            <label for="animation-speed">Animation Speed: <span id="animation-speed-value" class="slider-value">50</span></label>
            <input type="range" id="animation-speed" min="0" max="100" step="5" value="50">
        </div>
        
        <div class="control-group">
            <button id="toggle-nucleus">Toggle Nucleus</button>
            <button id="toggle-axes">Toggle Axes</button>
            <button id="toggle-labels">Toggle Labels</button>
        </div>
        
        <div class="control-group">
            <label for="color-nucleus">Nucleus Color:</label>
            <input type="color" id="color-nucleus" value="#ff0000">
            
            <label for="color-orbital">Orbital Color:</label>
            <input type="color" id="color-orbital" value="#0088ff">
            
            <label for="color-background">Background Color:</label>
            <input type="color" id="color-background" value="#000000">
        </div>
    </div>
    
    <div id="info">
        <h3 id="element-name">Hydrogen (H)</h3>
        <p id="element-info">Atomic Number: 1, Electron Configuration: 1s¹</p>
        <p id="orbital-info">Currently showing: All orbitals</p>
    </div>

    <!-- Import Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script src="https://github.com/mrdoob/three.js/raw/refs/heads/master/examples/jsm/controls/OrbitControls.js"></script>
    
    <script>
        // Main application code
        class QuantumAtomSimulator {
            constructor() {
                // Initialize properties
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.elements = {};
                this.currentElement = 1; // Hydrogen by default
                this.currentOrbital = "all";
                this.currentVisualization = "cloud";
                this.probabilityThreshold = 0.75;
                this.renderQuality = 50;
                this.animationSpeed = 50;
                this.showNucleus = true;
                this.showAxes = true;
                this.showLabels = true;
                this.nucleusColor = "#ff0000";
                this.orbitalColor = "#0088ff";
                this.backgroundColor = "#000000";
                
                // Object containers
                this.nucleus = null;
                this.orbitals = [];
                this.axes = null;
                this.labels = null;
                
                // Animation properties
                this.animationId = null;
                this.animationTime = 0;
                
                // Initialize elements data
                this.initElementsData();
                
                // Initialize the 3D scene
                this.initScene();
                
                // Initialize event listeners
                this.initEventListeners();
                
                // Start the simulation
                this.createAtomModel();
                this.animate();
            }
            
            initElementsData() {
                // Define element properties: atomic number, symbol, name, electron configuration
                this.elements = {
                    1: { symbol: "H", name: "Hydrogen", config: "1s¹" },
                    2: { symbol: "He", name: "Helium", config: "1s²" },
                    3: { symbol: "Li", name: "Lithium", config: "1s² 2s¹" },
                    4: { symbol: "Be", name: "Beryllium", config: "1s² 2s²" },
                    5: { symbol: "B", name: "Boron", config: "1s² 2s² 2p¹" },
                    6: { symbol: "C", name: "Carbon", config: "1s² 2s² 2p²" },
                    7: { symbol: "N", name: "Nitrogen", config: "1s² 2s² 2p³" },
                    8: { symbol: "O", name: "Oxygen", config: "1s² 2s² 2p⁴" },
                    9: { symbol: "F", name: "Fluorine", config: "1s² 2s² 2p⁵" },
                    10: { symbol: "Ne", name: "Neon", config: "1s² 2s² 2p⁶" }
                };
                
                // Orbital quantum numbers and properties
                this.orbitalsData = {
                    "1s": { n: 1, l: 0, m: 0, energy: -13.6 },
                    "2s": { n: 2, l: 0, m: 0, energy: -3.4 },
                    "2p": { n: 2, l: 1, m: 0, energy: -3.4 },
                    "3s": { n: 3, l: 0, m: 0, energy: -1.5 },
                    "3p": { n: 3, l: 1, m: 0, energy: -1.5 },
                    "3d": { n: 3, l: 2, m: 0, energy: -1.5 }
                };
            }
            
            initScene() {
                // Create scene
                this.scene = new THREE.Scene();
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75, // Field of view
                    window.innerWidth / window.innerHeight, // Aspect ratio
                    0.1, // Near clipping plane
                    1000 // Far clipping plane
                );
                this.camera.position.z = 10;
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(new THREE.Color(this.backgroundColor));
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Add orbit controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                directionalLight.position.set(10, 10, 10);
                this.scene.add(directionalLight);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            initEventListeners() {
                // Element selection
                document.getElementById('element').addEventListener('change', (e) => {
                    this.currentElement = parseInt(e.target.value);
                    this.updateAtomModel();
                    this.updateInfoPanel();
                });
                
                // Orbital selection
                document.getElementById('orbital').addEventListener('change', (e) => {
                    this.currentOrbital = e.target.value;
                    this.updateAtomModel();
                    this.updateInfoPanel();
                });
                
                // Visualization type
                document.getElementById('visualization').addEventListener('change', (e) => {
                    this.currentVisualization = e.target.value;
                    this.updateAtomModel();
                });
                
                // Probability threshold
                document.getElementById('probability').addEventListener('input', (e) => {
                    this.probabilityThreshold = parseFloat(e.target.value);
                    document.getElementById('probability-value').textContent = this.probabilityThreshold.toFixed(2);
                    this.updateAtomModel();
                });
                
                // Rendering quality
                document.getElementById('quality').addEventListener('input', (e) => {
                    this.renderQuality = parseInt(e.target.value);
                    document.getElementById('quality-value').textContent = this.renderQuality;
                    this.updateAtomModel();
                });
                
                // Animation speed
                document.getElementById('animation-speed').addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                    document.getElementById('animation-speed-value').textContent = this.animationSpeed;
                });
                
                // Toggle buttons
                document.getElementById('toggle-nucleus').addEventListener('click', () => {
                    this.showNucleus = !this.showNucleus;
                    if (this.nucleus) {
                        this.nucleus.visible = this.showNucleus;
                    }
                });
                
                document.getElementById('toggle-axes').addEventListener('click', () => {
                    this.showAxes = !this.showAxes;
                    if (this.axes) {
                        this.axes.visible = this.showAxes;
                    }
                });
                
                document.getElementById('toggle-labels').addEventListener('click', () => {
                    this.showLabels = !this.showLabels;
                    if (this.labels) {
                        this.labels.visible = this.showLabels;
                    }
                });
                
                // Color pickers
                document.getElementById('color-nucleus').addEventListener('input', (e) => {
                    this.nucleusColor = e.target.value;
                    if (this.nucleus) {
                        this.nucleus.material.color.set(this.nucleusColor);
                    }
                });
                
                document.getElementById('color-orbital').addEventListener('input', (e) => {
                    this.orbitalColor = e.target.value;
                    this.updateOrbitalColors();
                });
                
                document.getElementById('color-background').addEventListener('input', (e) => {
                    this.backgroundColor = e.target.value;
                    this.renderer.setClearColor(new THREE.Color(this.backgroundColor));
                });
            }
            
            createAtomModel() {
                // Clear existing model
                this.clearAtomModel();
                
                // Create nucleus
                this.createNucleus();
                
                // Create coordinate axes
                this.createAxes();
                
                // Create orbital visualizations
                this.createOrbitals();
                
                // Create labels
                this.createLabels();
                
                // Update the information panel
                this.updateInfoPanel();
            }
            
            updateAtomModel() {
                // Clear and recreate the atom model with new settings
                this.createAtomModel();
            }
            
            clearAtomModel() {
                // Remove existing nucleus
                if (this.nucleus) {
                    this.scene.remove(this.nucleus);
                    this.nucleus = null;
                }
                
                // Remove existing orbitals
                if (this.orbitals && this.orbitals.length) {
                    this.orbitals.forEach(orbital => {
                        this.scene.remove(orbital);
                    });
                    this.orbitals = [];
                }
                
                // Remove existing axes
                if (this.axes) {
                    this.scene.remove(this.axes);
                    this.axes = null;
                }
                
                // Remove existing labels
                if (this.labels) {
                    this.scene.remove(this.labels);
                    this.labels = null;
                }
            }
            
            createNucleus() {
                // Create a sphere to represent the nucleus
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: this.nucleusColor,
                    emissive: new THREE.Color(this.nucleusColor).multiplyScalar(0.2),
                    specular: 0xffffff,
                    shininess: 50
                });
                
                this.nucleus = new THREE.Mesh(geometry, material);
                this.nucleus.visible = this.showNucleus;
                this.scene.add(this.nucleus);
            }
            
            createAxes() {
                // Create coordinate axes
                this.axes = new THREE.Group();
                
                // X-axis (red)
                const xAxisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 16);
                const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
                xAxis.rotation.z = Math.PI / 2;
                this.axes.add(xAxis);
                
                // Y-axis (green)
                const yAxisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 16);
                const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
                this.axes.add(yAxis);
                
                // Z-axis (blue)
                const zAxisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 16);
                const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
                zAxis.rotation.x = Math.PI / 2;
                this.axes.add(zAxis);
                
                this.axes.visible = this.showAxes;
                this.scene.add(this.axes);
            }
            
            createOrbitals() {
                this.orbitals = [];
                
                // Determine which orbitals to show based on current element and orbital selection
                const orbitalsToShow = this.getOrbitalsToShow();
                
                // Create visualization for each orbital
                orbitalsToShow.forEach(orbitalName => {
                    const orbital = this.orbitalsData[orbitalName];
                    if (orbital) {
                        const orbitalObj = this.createOrbitalVisualization(orbitalName, orbital);
                        if (orbitalObj) {
                            this.scene.add(orbitalObj);
                            this.orbitals.push(orbitalObj);
                        }
                    }
                });
            }
            
            getOrbitalsToShow() {
                // If we're showing all orbitals, determine which ones are populated for this element
                if (this.currentOrbital === "all") {
                    // Determine which orbitals are filled based on electron configuration
                    const orbitalsToShow = [];
                    
                    // Simplified approach - determine which orbitals to show based on element
                    if (this.currentElement >= 1) orbitalsToShow.push("1s");
                    if (this.currentElement >= 3) orbitalsToShow.push("2s");
                    if (this.currentElement >= 5) orbitalsToShow.push("2p");
                    if (this.currentElement >= 11) orbitalsToShow.push("3s");
                    if (this.currentElement >= 13) orbitalsToShow.push("3p");
                    if (this.currentElement >= 21) orbitalsToShow.push("3d");
                    
                    return orbitalsToShow;
                } else {
                    // Return just the selected orbital
                    return [this.currentOrbital];
                }
            }
            
            createOrbitalVisualization(orbitalName, orbital) {
                // Get orbital quantum numbers
                const { n, l, m } = orbital;
                
                // Create different visualizations based on user selection
                switch (this.currentVisualization) {
                    case "cloud":
                        return this.createElectronCloud(n, l, m);
                    case "boundary":
                        return this.createBoundarySurface(n, l, m);
                    case "dots":
                        return this.createProbabilityDots(n, l, m);
                    case "wireframe":
                        return this.createWireframe(n, l, m);
                    default:
                        return this.createElectronCloud(n, l, m);
                }
            }
            
            // Different visualization methods for orbitals
            
            createElectronCloud(n, l, m) {
                // Create a particle system to represent electron cloud
                const particleCount = 1000 * (this.renderQuality / 50);
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                const orbitalColor = new THREE.Color(this.orbitalColor);
                
                // Generate particles based on probability distribution
                for (let i = 0; i < particleCount; i++) {
                    // Generate random spherical coordinates
                    const r = this.getRadialDistribution(n, l);
                    const theta = Math.random() * Math.PI;
                    const phi = Math.random() * 2 * Math.PI;
                    
                    // Convert to Cartesian coordinates
                    const x = r * Math.sin(theta) * Math.cos(phi);
                    const y = r * Math.sin(theta) * Math.sin(phi);
                    const z = r * Math.cos(theta);
                    
                    // Apply orbital angular dependency
                    let probability = this.getAngularDistribution(l, m, theta, phi);
                    
                    // Only place particle if probability is above threshold
                    if (Math.random() < probability) {
                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                        
                        // Vary color based on probability and distance
                        const alpha = probability * (1 - r / (n * 2));
                        colors[i * 3] = orbitalColor.r * alpha;
                        colors[i * 3 + 1] = orbitalColor.g * alpha;
                        colors[i * 3 + 2] = orbitalColor.b * alpha;
                    }
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending
                });
                
                const cloud = new THREE.Points(particles, material);
                
                // Add metadata for animation
                cloud.userData = { type: 'cloud', n, l, m };
                
                return cloud;
            }
            
            createBoundarySurface(n, l, m) {
                // Create a 3D surface representing electron boundary (probability isosurface)
                let geometry;
                let scale = n;
                
                // Different shapes based on orbital type
                if (l === 0) {
                    // s orbital is spherical
                    geometry = new THREE.SphereGeometry(
                        scale, 
                        32 * this.renderQuality / 50, 
                        32 * this.renderQuality / 50
                    );
                } else if (l === 1) {
                    // p orbital is dumbbell-shaped
                    if (m === 0) {
                        // pz
                        geometry = new THREE.SphereGeometry(
                            scale, 
                            32 * this.renderQuality / 50, 
                            32 * this.renderQuality / 50
                        );
                        geometry.scale(0.5, 0.5, 1.5);
                    } else if (m === 1) {
                        // px
                        geometry = new THREE.SphereGeometry(
                            scale, 
                            32 * this.renderQuality / 50, 
                            32 * this.renderQuality / 50
                        );
                        geometry.scale(1.5, 0.5, 0.5);
                    } else {
                        // py
                        geometry = new THREE.SphereGeometry(
                            scale, 
                            32 * this.renderQuality / 50, 
                            32 * this.renderQuality / 50
                        );
                        geometry.scale(0.5, 1.5, 0.5);
                    }
                } else if (l === 2) {
                    // d orbital (simplified)
                    geometry = new THREE.SphereGeometry(
                        scale, 
                        32 * this.renderQuality / 50, 
                        32 * this.renderQuality / 50
                    );
                    // Apply different scaling based on m value
                    switch (m) {
                        case 0: // dz²
                            geometry.scale(0.7, 0.7, 1.5);
                            break;
                        case 1: // dxz
                            geometry.scale(1.2, 0.8, 1.2);
                            break;
                        case 2: // dxy
                            geometry.scale(1.2, 1.2, 0.8);
                            break;
                        default:
                            geometry.scale(1, 1, 1);
                    }
                }
                
                const material = new THREE.MeshPhongMaterial({
                    color: this.orbitalColor,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const surface = new THREE.Mesh(geometry, material);
                
                // Add metadata for animation
                surface.userData = { type: 'surface', n, l, m };
                
                return surface;
            }
            
            createProbabilityDots(n, l, m) {
                // Similar to electron cloud but more structured to show probability
                const particleCount = 2000 * (this.renderQuality / 50);
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                const orbitalColor = new THREE.Color(this.orbitalColor);
                
                // Create more structured probability distribution
                for (let i = 0; i < particleCount; i++) {
                    // Use structured sampling for more defined orbital shapes
                    const r = this.getRadialDistribution(n, l);
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = 2 * Math.PI * Math.random();
                    
                    const x = r * Math.sin(theta) * Math.cos(phi);
                    const y = r * Math.sin(theta) * Math.sin(phi);
                    const z = r * Math.cos(theta);
                    
                    let probability = this.getAngularDistribution(l, m, theta, phi);
                    
                    if (probability > this.probabilityThreshold) {
                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                        
                        colors[i * 3] = orbitalColor.r * probability;
                        colors[i * 3 + 1] = orbitalColor.g * probability;
                        colors[i * 3 + 2] = orbitalColor.b * probability;
                    }
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    transparent: false
                });
                
                const dots = new THREE.Points(particles, material);
                dots.userData = { type: 'dots', n, l, m };
                
                return dots;
            }
            
            createWireframe(n, l, m) {
                // Create a wireframe version of the boundary surface
                const surface = this.createBoundarySurface(n, l, m);
                
                if (surface) {
                    surface.material.wireframe = true;
                    surface.material.opacity = 1.0;
                }
                
                return surface;
            }
            
            getRadialDistribution(n, l) {
                // Simplified radial distribution function based on quantum numbers
                // This creates a distribution that peaks around n * a₀
                const a0 = 1; // Bohr radius (scaled)
                const r = -Math.log(Math.random()) * n * a0;
                
                return r;
            }
            
            getAngularDistribution(l, m, theta, phi) {
                // Simplified angular distribution based on spherical harmonics
                
                let probability = 1.0;
                
                if (l === 0) {
                    // s orbitals: uniform in all directions
                    probability = 1.0;
                } else if (l === 1) {
                    // p orbitals: simplified
                    if (m === 0) {
                        // pz: concentrated along z-axis
                        probability = Math.abs(Math.cos(theta));
                    } else if (m === 1) {
                        // px: concentrated along x-axis
                        probability = Math.abs(Math.sin(theta) * Math.cos(phi));
                    } else {
                        // py: concentrated along y-axis
                        probability = Math.abs(Math.sin(theta) * Math.sin(phi));
                    }
                } else if (l === 2) {
                    // d orbitals: simplified
                    probability = Math.pow(Math.sin(theta), 2);
                }
                
                return probability;
            }
            
            createLabels() {
                // Create text labels for axes and other elements
                this.labels = new THREE.Group();
                this.labels.visible = this.showLabels;
                this.scene.add(this.labels);
            }
            
            updateOrbitalColors() {
                // Update orbital colors when user changes the color
                this.orbitals.forEach(orbital => {
                    if (orbital.material) {
                        if (orbital.material instanceof THREE.PointsMaterial) {
                            // For point clouds, need to update vertex colors
                            const colors = orbital.geometry.attributes.color.array;
                            const orbitalColor = new THREE.Color(this.orbitalColor);
                            
                            for (let i = 0; i < colors.length; i += 3) {
                                if (colors[i] > 0 || colors[i+1] > 0 || colors[i+2] > 0) {
                                    const intensity = (colors[i] + colors[i+1] + colors[i+2]) / 3;
                                    colors[i] = orbitalColor.r * intensity;
                                    colors[i+1] = orbitalColor.g * intensity;
                                    colors[i+2] = orbitalColor.b * intensity;
                                }
                            }
                            
                            orbital.geometry.attributes.color.needsUpdate = true;
                        } else {
                            // For meshes, just update the material color
                            orbital.material.color.set(this.orbitalColor);
                        }
                    }
                });
            }
            
            updateInfoPanel() {
                // Update the information panel with current element and orbital details
                const element = this.elements[this.currentElement];
                
                document.getElementById('element-name').textContent = `${element.name} (${element.symbol})`;
                document.getElementById('element-info').textContent = `Atomic Number: ${this.currentElement}, Electron Configuration: ${element.config}`;
                
                if (this.currentOrbital === "all") {
                    document.getElementById('orbital-info').textContent = "Currently showing: All orbitals";
                } else {
                    const orbital = this.orbitalsData[this.currentOrbital];
                    if (orbital) {
                        document.getElementById('orbital-info').textContent = 
                            `Currently showing: ${this.currentOrbital} orbital (n=${orbital.n}, l=${orbital.l}, m=${orbital.m})`;
                    }
                }
            }
            
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                // Update animation time
                this.animationTime += 0.01 * (this.animationSpeed / 50);
                
                // Animate orbitals
                this.animateOrbitals();
                
                // Update controls
                this.controls.update();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            animateOrbitals() {
                // Animate orbital visualizations based on their type
                this.orbitals.forEach(orbital => {
                    if (orbital.userData) {
                        const type = orbital.userData.type;
                        
                        if (type === 'cloud') {
                            // Make cloud particles "shimmer"
                            if (orbital.geometry && orbital.geometry.attributes) {
                                const positions = orbital.geometry.attributes.position.array;
                                
                                for (let i = 0; i < positions.length; i += 3) {
                                    if (Math.random() < 0.1) {
                                        const delta = (Math.random() - 0.5) * 0.05;
                                        positions[i] += delta;
                                        positions[i+1] += delta;
                                        positions[i+2] += delta;
                                    }
                                }
                                
                                orbital.geometry.attributes.position.needsUpdate = true;
                            }
                        } else if (type === 'surface' || type === 'wireframe') {
                            // Subtle pulsing animation
                            const scale = 1 + 0.05 * Math.sin(this.animationTime);
                            orbital.scale.set(scale, scale, scale);
                            
                            // Slight rotation
                            orbital.rotation.x = Math.sin(this.animationTime * 0.2) * 0.1;
                            orbital.rotation.y = Math.cos(this.animationTime * 0.3) * 0.1;
                        }
                    }
                });
            }
        }
        
        // Initialize the application when page is loaded
        window.addEventListener('load', () => {
            const simulator = new QuantumAtomSimulator();
        });
    </script>
</body>
</html>
